/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "com_ptr.h"
#include "BMDSwitcherAPI.h"
#include <cstdio>
#include <map>
#include <string>
#include <utility>
#include <vector>
#include <libkern/OSAtomic.h>
#include <iostream>

static const std::map<BMDSwitcherConnectToFailure, std::string> kConnectFailReasonCodes =
{
	{ bmdSwitcherConnectToFailureNoResponse,			"No response" },
	{ bmdSwitcherConnectToFailureIncompatibleFirmware,	"Incompatible firmware" },
	{ bmdSwitcherConnectToFailureCorruptData,			"Corrupt data" },
	{ bmdSwitcherConnectToFailureStateSync,				"State synchronisation failed" },
	{ bmdSwitcherConnectToFailureStateSyncTimedOut,		"State synchronisation timed-out" },
};

std::string CFStringToStdString(CFStringRef str)
{
	CFIndex stringSize = CFStringGetLength(str) + 1;
	char buffer[stringSize];
	CFStringEncoding encoding = CFStringGetSystemEncoding();
	const char *ptr = CFStringGetCStringPtr(str, encoding);
	if (ptr == NULL)
	{
		if (CFStringGetCString(str, buffer, stringSize, encoding))
			ptr = buffer;
	}
	return ptr;
}


template<typename T>
std::string LookupString(const std::map<T, std::string>& stringMap, T index)
{
	std::string connectFailReasonStr;
	auto iter = stringMap.find(index);

	if (iter != stringMap.end())
		return iter->second;
	else
		return "Unknown";
}

std::string get_product_name(com_ptr<IBMDSwitcher>& switcher)
{
    CFStringRef productNameString;

    // *** Print the product name of the Switcher
    if (switcher->GetProductName(&productNameString) != S_OK)
    {
        return "N/A";
    }

    std::string productName("");
    CFIndex stringSize = CFStringGetLength(productNameString) + 1;
    char stringBuffer[stringSize];
    if (CFStringGetCString(productNameString, stringBuffer, stringSize, kCFStringEncodingUTF8))
        productName = stringBuffer;

    CFRelease(productNameString);
    return productName;
}

class MyCallbackClass : public IBMDSwitcherCallback
{
    public:
       MyCallbackClass(com_ptr<IBMDSwitcher>* switcher, MyCallbackClass* other);

    public:
       // IUnknown
       HRESULT        QueryInterface(REFIID iid, LPVOID* ppv);
       ULONG        AddRef(void);
       ULONG        Release(void);

       // IBMDSwitcherCallback
    HRESULT Notify(BMDSwitcherEventType eventType, BMDSwitcherVideoMode coreVideoMode);

    private:
       ~MyCallbackClass(); // Call Release()
        com_ptr<IBMDSwitcher>* switcher;
        MyCallbackClass* other;
       int32_t                            mRefCount;
};

MyCallbackClass::MyCallbackClass(com_ptr<IBMDSwitcher>* s, MyCallbackClass* o)
 : mRefCount(1)
{
    switcher = s;
    other = o;
}

HRESULT MyCallbackClass::QueryInterface(REFIID iid, LPVOID *ppv)
{
    if (!ppv)
        return E_POINTER;

    if (CFEqual(&iid, &IID_IBMDSwitcherCallback))
    {
        *ppv = static_cast<MyCallbackClass*>(this);
        AddRef();
        return S_OK;
    }

    if (CFEqual(&iid, IUnknownUUID))
    {
        *ppv = static_cast<IUnknown*>(this);
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG MyCallbackClass::AddRef(void)
{
    return ::OSAtomicIncrement32(&mRefCount);
}

ULONG MyCallbackClass::Release(void)
{
    int newCount = ::OSAtomicDecrement32(&mRefCount);
    if (newCount == 0)
        delete this;
    return newCount;
}

HRESULT MyCallbackClass::Notify(BMDSwitcherEventType eventType, BMDSwitcherVideoMode coreVideoMode)
{
    // Filtering down to the event doesn't change the bug but it makes it clearer what's going on.
    if (eventType == bmdSwitcherEventTypeDisconnected) {
        std::cout << "\n" << this << " DISCONNECTED! " << std::endl;

        if (other != nil) {
            HRESULT result = switcher->get()->RemoveCallback(other);
            std::cout << this << " removing Callback " << other << " " << result << std::endl;
            if (result != S_OK) {
                std::cout << "ERROR REMOVING CALLBACK!!!!!!" << std::endl;
            }
        }
    }

    return S_OK;
}


MyCallbackClass::~MyCallbackClass()
{
}

int main (int argc, char** argv)
{
	com_ptr<IBMDSwitcherDiscovery>						switcherDiscovery;
	com_ptr<IBMDSwitcher>								switcher;
	std::string											productName;

	BMDSwitcherConnectToFailure							connectToFailReason;
	HRESULT												result;

	if (argc != 2)
	{
		fprintf(stderr, "Expected: %s <ip_address>\n", argv[0]);
		return 1;
	}

	switcherDiscovery = CreateBMDSwitcherDiscoveryInstance();
	if (!switcherDiscovery)
	{
		fprintf(stderr, "A Switcher Discovery instance could not be created.  The Switcher drivers may not be installed.\n");
		return 1;
	}

	// Connect to switcher with address provided by argv
	CFStringRef addressString = CFStringCreateWithCString(kCFAllocatorDefault, argv[1], kCFStringEncodingUTF8);
	result = switcherDiscovery->ConnectTo(addressString, switcher.releaseAndGetAddressOf(), &connectToFailReason);
	if (result != S_OK)
	{
		std::string connectFailReasonStr = LookupString<BMDSwitcherConnectToFailure>(kConnectFailReasonCodes, connectToFailReason);
		fprintf(stderr, "Failed to connect to switcher at address %s, reason = %s\n", argv[1], connectFailReasonStr.c_str());
		return 1;
	}
	CFRelease(addressString);

	// Print switcher product name
	printf("Switcher found at %s\n", argv[1]);
	productName = get_product_name(switcher);
	printf(" %-40s %s\n", "Product Name:", productName.c_str());

    MyCallbackClass* b = new MyCallbackClass(&switcher, nil);
    MyCallbackClass* a = new MyCallbackClass(&switcher, b);
    switcher->AddCallback(a);
    switcher->AddCallback(b);

    usleep(2808348671);

	return 0;
}
